 Level 32
 
 Вопросы к собеседованиям
 
1	Зачем нужен RandomAccessFile?



2	Что будет если файл, откуда читает RandomAccessFile, не существует?



3	Что будет если файл, куда пишет RandomAccessFile, не существует?



4	Зачем нужен класс StringReader?



5	Зачем нужен класс StringWriter?



6	Зачем нужен класс ByteArrayStream?



7	Зачем нужен класс PrintStream? Назовите места, где он используется?



8	Зачем нужен DynamicProxy?



9	Как работает RMI?



10	Объекты каких типов можно передавать по RMI?

 
 
 1	Зачем нужен RandomAccessFile?
 
RandomAccessFile — класс пакета Java IO API, он позволяет перемещаться по файлу, читать из него или писать в него, как вам будет угодно. Вы также сможете заменить существующие части файла, речь идет о обновлении содержимого файла, а точней о обновлении фрагмента файла. Это невозможно сделать с помощью FileInputStream или FileOutputStream, но RandomAccessFile даст вам эту возможность.
Ссылка: http://devcolibri.com/2989

2	Что будет если файл, откуда читает RandomAccessFile, не существует?
Будет FileNotFoundException

3	Что будет если файл, куда пишет RandomAccessFile, не существует?
Создаст новый и запишет в него.

4	Зачем нужен класс StringReader?
The Java.io.StringReader class is a character stream whose source is a string.
Представляет собой поток символов, чей источник называется строкой

5	Зачем нужен класс StringWriter?
public class StringWriter
extends Writer
A character stream that collects its output in a string buffer, which can then be used to construct a string.
Closing a StringWriter has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.
Поток символов, собирающий свой поток в буфер строк, которые затем могут быть использованы для создания строки. 

6	Зачем нужен класс ByteArrayStream?
Итак, ByteArrayInputStream и ByteArrayOutputStream.
Эти классы по сути чем-то похожи на StringReader и StringWriter. Только StringReader читал символы (char) из строки (String), а InputStream читает байты из массива байт (ByteArray).
StringWriter писал символы (char) в строку, а ByteArrayOutputStream пишет байты в массив байт у него внутри. При записи в StringWriter строка внутри него удлинялась, а при записи вByteArrayOutputStream его внутренний массив байт тоже динамически расширяется.

7	Зачем нужен класс PrintStream? Назовите места, где он используется?
Класс PrintStream был придуман для читабельного вывода информации. Он практически весь состоит из методов print и println.

8	Зачем нужен DynamicProxy?
В Java есть специальный класс (java.lang.reflect.Proxy), с помощью которого фактически можно сконструировать объект во время исполнения программы (динамически), не создавая для него отдельного класса.

9	Как работает RMI?
RMI расшифровывается Remote Method Invokation – удаленный вызов методов. Или другими словами RMI – это механизм, который позволяет объекту в одной Java-машине вызывать методы объекта в другой Java-машине, даже если они находятся на разных компьютерах, в разных странах, на разных сторонах земного шара.
Традиционный подход к выполнению кода на других машинах, разнесенных по сети может смутить из-за своей нудной и склонной к ошибкам реализации. Лучший способ рассмотреть эту проблему состоит в предположении, что некоторые объекты располагаются на другой машине, и что вы можете посылать сообщения этим удаленным объектам и получать результат, как будто они располагаются на вашей локальной машине. Это упрощение в точности является тем, что позволяет делать Удаленный Вызов Методов (RMI) в Java. 
Вот статья по созданию собственной реализации RMI:
http://javatutor.net/books/tiej/rmi

10	Объекты каких типов можно передавать по RMI?
Объекты должны имплементировать интерфейс Serializable
Remote method Invocation — механизм, который позволяет вызывать метод удалённого объекта. Согласно ему, все операции по подготовке и передаче данных инкапсулируются в вызываемом методе клиентского объекта-заглушки (stub). Сам же вызов метода ничем не отличается от вызова метода обычного локального объекта, за небольшим исключением:

локальные объекты передаются по значению (копии);
при передаче удалённого (Remote) объекта, если он экспортирован, передаётся stub этого объекта;
передаваемые объекты должны быть Serializable;
кроме всех прочих исключительных ситуаций, при вызове удалённого метода может возбуждаться исключение RemoteException (ошибки маршализации/демаршализации, передачи данных и другие возможные ошибки протокола);
Так же нужно отметить, что при вызове метода мы работаем с удалённым интерфейсом, а не с удалённым классом.
 
 
 
 
