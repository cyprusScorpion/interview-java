 

Юрий Кузнецов
35 уровень
13 октября 2018 0:48
3374просмотра
49комментариев
23 вопроса, часто задаваемых на собеседованиях
Пост из группы Москва
39244 участников
Расскажу быстренько о себе. 

Мне 25 лет, родился в Крыму, г. Феодосия. Учился в техникуме городском, потом поступил в Харьков, получил диплом бакалавра и в 2014 году вернулся обратно домой. В 2014 поступил на заочное обучение на магистра (все специальности были кое-как связанны с программированием), и в 2015-м году поступил в армию на контрактную службу сроком на 3 года. После двух лет службы в армии я понял, что надо что-то менять в своей жизни... 

И вот мне попадается JavaRush в декабре 2017 года, и я начинаю упорно учить Java. Летом я попадаю на курсы Topjava к Григорию, начинаю проходить каждое его занятие, и к середине сентября должны были закончатся трехмесячные курсы. 

В общем, в начале сентября я переезжаю в Москву с женой для поиска работы Java программистом и на сегодняшний день прошел примерно 10 собеседований. Я вам напишу то, что постоянно спрашивают и вопросы, на которых я сыпался.
Что такое JDK,JRE,JVM и компилятор. This is must have. Если вам зададут на собеседовании этот вопрос и вы не ответите на него, скорее всего, дальше ничего спрашивать не будут. Маленькое видео с youtube

Объектно ориентированное программирование (ООП). Тут главное рассказать, что такое полиморфизм. Могут попросить перевести это слово, потом нужно рассказать его определение соответственно. Можно рассказывать все своими словами. Потом приводите свои примеры.

Доп. литература : Полиморфизм

Видео: Введение в ООП

Множественное наследование в Java.В Java запрещено множественное наследование классов, но разрешено множественное наследование интерфейсов. О наследовании

Методы класса Object (желательно каждый метод посмотреть прямо в самом коде и обратить внимание на Equals и hashCode). Я называл так: getClass, finallize (прочитайте о нем, мало ли зададут вопрос, но запомните: как по мне — ЭТО КОСТЫЛЬ), wait (достаточно знать, что там 3 перегруженных метода) notify, notifyAll, equals и hashcode (обязательно!!! знать 4 правила equals и обязательно знать закон между equals и hashCode).

Object Java

JVM изнутри. Stack и Heap память.

Память

Что за ключевое слово new и как оно работает. Материал не нашел, но у меня спрашивали о нем, а точнее, когда мы пишем к примеру
A a = new A()

что происходит перед равно и после равно?
Перед равно у нас создается ссылка, а после равно у нас создается с помощью ключевого слова new новый объект, который помещается в память Heap в виде набора байт.(если я не прав потом поправьте пожалуйста меня)

Работа Garbage Collection — не очень часто спрашивали, но когда спрашивали начинали копать, насколько я знаю данную тему. Отличная статья на тут

Порядок инициализации полей классов родителя и потомка

Коллекции: приходилось рассказывать абсолютно всю иерархию и работу каждой коллекции.

Вопрос, чем отличается List от Set. Самое главное — сказать, что из себя представляет интерфейс List. Если вы ответите, что Set — коллекция с уникальными объектами, этого будет недостаточно.

HashMap, HashSet — начальный размер; capacity, loadfactory, null допускается или нет? Как вычисляется ячейка для объекта при работе с Hash коллекцией? Отличие HashMap от TreeMap (недостаточно сказать, что TreeMap — отсортированная коллекция, по алгоритму красно-черное дерево). Знать алгоритмы вставки, удаления, поиска o каждой коллекции. Queue, Deque, Stack — редко задавали мне вопросы о них. Нужно знать, где интерфейс, а где классы в коллекциях.


Обратите внимание на то, что у Collections есть родитель Iterable

ссылка от нашего участника)

Java 8. Абсолютно по максимуму должны выжать из себя все что знаете о "нововведениях", выпущенных 4 года назад: вот вам источник Новое в Java 8

У меня спрашивали о consumers, function и т.п., потом спрашивали о функциональных интерфейсах, потом спрашивали, как создать свою аннотацию, что означает например @SomeAnnotation (name = .... count =....), а именно, что тут name, count и как они работают при создании своей аннотации.

Generics. Все о дженериках. Спрашивают везде.

Дженерики

Потоки. Thread, Runnable, чем отличаются, как запустить поток. Все о синхронизации. Мьютексы, мониторы, класс Lock. Deadlock когда возникает, приведи те примеры.

Иерархия исключений checked/unchecked, написать свой класс исключения.


Final, finallize(опять), immutable, finally. Когда не отработает блок finally.

Как запретить наследования классов (приватные конструкторы, финал класс...).

IO / NIO потоки.

ПАТТЕРНЫ. Выучите хотя бы 5 штук основных (mvc, factory, decorator, singleton, наблюдатель).

Spring ioc, di, ioc - container. Вот вам ссылка на практическое понимание, мне очень помогло... SPRING. Я тут по спрингу прошел до 16 главы, писав вручную весь код. Советую и вам поступить так же.

Maven -> профили, артефакты, war, jar... виды scope. Какие параметры задавать надо при подключении библиотек.

MAVEN

Что такое ORM? как работает? (изи ответ).

Hibernate: как связывается с базой данных, что должно быть обязательно при создании класса Entity. Session. 3 уровня кэширования — знать. Как связать таблицу и класс entity. Связи:

Многие ко многим, один ко многим и т.п.

Если у нас есть связь, например, User у которого много Book. Как будет выглядеть поле в классе User и поле в классе Book (это там где указывается аннотация многие ко одному и один ко многим над полями).

Что такое JPA, каким образом он связан с Hiber. JPAQL.

Hibernate

Следующий вопрос будет по SQL. Запросы, какие знаешь, что использовал. JOIN — внешний, внутренний, левый, правый.

sql

Задача из компании: 2 таблицы дано, департамент и сотрудник. Вот пример.

Горизонтальное масштабирование .

Маленькое видео на тему вертикального и горизонтального масштабирования
Немного html, css, js.

Git. Работа в консоли. commit, push, в чем отличие fetch от pull.


Напоследок, советую читать этот список вопросов и искать ответы самому (качаем навык "гуглить") и писать код для закрепления.

P.S. : статья моя первая, так что по-любому будут недостатки, пишите, буду очень рад комментариям.

Дополнительная литература, если вам этого еще не достаточно:

И еще вопросы

27. Как сделать коллекцию только для чтения?
28. Как сделать потокобезопасную коллекцию?
29. Почему не существует метода Iterator.add() для добавления элементов в коллекцию?
30. Какие существуют способы перебирать элементы списка?
31. Как вы понимаете работу свойства итератора fail-fast?
32. Какая разница между fail-fast и fail-safe?
33. Как избежать ConcurrentModificationException во время перебора коллекции?
34. Что такое UnsupportedOperationException?
35. Какие классы коллекций дают доступ к любому элементу?
36. Что такое BlockingQueue?
37. Что такое очередь и стэк, перечислите различия между ними?
38. Что такое интерфейсы Comparable и Comparator?
39. Что такое классы Collections и Arrays?
40. Список использованной литературы

Не тратя зря время, приступим к объяснениям

Вопросы о различиях разных коллекций

18. Назовите различия между Set и List?
Список ключевых различий:
Множества - неупорядоченные коллекции, тогда как списки - упорядоченные, где каждый элемент имеет индекс начинающийся с нуля.
Списки могут содержать два и более одинаковых элемента, а множества не могут.
В списке может содержаться сколько угодно элементов null, в множестве - только один.

19. Назовите различия между List и Map?
Самый легкий вопрос. Список это коллекция элементов, а словарь это коллекция пар ключ/значение. Есть еще множество изменений, но все они являются следствием данного. У них разный интерфейс верхнего уровня, разный набор методов и разные представления данных.
В большинстве случаев достаточно только первого ответа.

20. Назовите различия между HashMap и HashTable?
Есть несколько различий между HashMap и HashTable в Java:
HashTable потокобезопасна, а HashMap нет
HashTable не может содержать элементы null, тогда как HashMap может содержать один ключ null и любое количество значений null
Третье ключевое отличие между ними - итератор у HashMap, в отличие от перечислителя HashTable, работает по принципу fail-fast (выдает исключение при любой несогласованности данных)


21.  Назовите различия между Vector и ArrayList?
Отметим некоторые различия:
Все методы Vector потокобезопасны, а у ArrayList - нет
Vector это устаревший класс добавленный в первом релизе JDK. ArrayList появился в JDK 1.2, вместе с остальными классами фреймворка Collection
По умолчанию, Vector удваивает свой размер когда заканчивается выделенная под элементы память. ArrayList же увеличивает свой размер только на половину


22.  Назовите различия между Iterator и Enumeration?
Итераторы отличаются от перечислителей по трем признакам:
Существуют итераторы, которые позволяют удалять элементы из своей коллекции во время перебора, с использованием метода remove(). Класс Iterator данного функционала не поддерживает. С помощью перечислителя нельзя добавлять/удалять элементы
Перечислители присутствуют в устаревших классах, таких как Vector/Stack, тогда как итераторы есть во всех современных классах-коллекциях
Еще небольшое отличие в том, что у итераторов и перечислителей различается наименование методов, то есть Enumeration.hasMoreElements() соответствует Iterator.hasNext() и Enumeration.nextElement() соответствует Iterator.next() и т.д.


23. Назовите различия между HashMap и HashSet?
HashMap - коллекция пар ключ/значение, тогда как HashSet это упорядоченная коллекция уникальных элементов. И это все, не требуется больше никаких объяснений.

24. Назовите различия между Iterator и ListIterator?
Есть три различия:
Iterator может использоваться для перебора элементов Set, List и Map. В отличие от него, ListIterator может быть использован только для перебора элементов коллекции List
Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous()
При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove(). Iterator не поддерживает данного функционала


25. Назовите различия между TreeSet и SortedSet?
SortedSet это интерфейс, реализуемый классом TreeSet. Вот и все!

26.Назовите различия между ArrayList и LinkedList?
LinkedList хранит элементы в двусвязном списке, тогда как ArrayList хранит их в массиве, размер которого может динамически меняться
LinkedList поддерживает добавление/удаление элементов за фиксированное время, но только последовательный доступ к элементам. То есть, вы можете перебрать список с начала в конец и с конца в начало, но получение элемента в середине списка займет время пропорциональное размеру списка. ArrayList же позволяет получить любой элемент по его индексу за фиксированное время. Но добавление/удаление элементов туда требует затрат времени пропорциональных размеру, потому что нужно подвинуть все элементы с места вставки/удаления и до конца списка, либо чтобы освободить место для вставляемого либо чтобы убрать пропуск на месте удаленного
LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто идут по порядку


И еще вопросы

27. Как сделать коллекцию только для чтения?
Используйте следующие методы:
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);

Все они принимают коллекцию в качестве параметра, и возвращают коллекцию только для чтения с теми же элементами внутри.

28. Как сделать потокобезопасную коллекцию?
Используйте следующие методы:
Collections.synchronizedList(list);
Collections.synchronizedSet(set);
Collections.synchronizedMap(map);

Все они принимают коллекцию в качестве параметра, и возвращают потокобезопасную коллекцию с теми же элементами внутри.

29. Почему не существует метода Iterator.add() для добавления элементов в коллекцию?
Единственная задача итератора это перебор коллекции. Каждая коллекция имеет метод add() которым вы можете воспользоваться. Нет смысла добавлять этот метод в итератор, потому что коллекции могут быть упорядоченными и неупорядоченными, и метод add() при этом должен быть устроен по разному.

30. Какие существуют способы перебирать элементы списка?
Есть 4 способа:
Цикл с итератором
Цикл for
Расширенный цикл for
Цикл while

Читайте статью.

31. Как вы понимаете работу свойства итератора fail-fast?
Итератор fail-fast вызывает исключение сразу как обнаружит что структура коллекции была изменена после начала перебора. Под изменением структуры мы понимаем добавление/удаление/изменение элемента коллекции, в то время как другой поток перебирает эту коллекцию.

32. Какая разница между fail-fast и fail-safe?
В противоположность fail-fast, итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.
Итератор коллекции CopyOnWriteArrayList и итератор представления keySet коллекции ConcurrentHashMap являются примерами итераторов fail-safe.

33. Как избежать ConcurrentModificationException во время перебора коллекции?
Первым делом, можно подобрать другой итератор, работающий по принципу fail-safe. К примеру, если вы используете List, то можете взять ListIterator. Если же вам нужна устаревшая коллекция - то используйте перечислители.
В том случае, когда вышеизложенное вам не подходит, у вас есть три варианта:
При использовании JDK 1.5 или выше, вам подойдут классы ConcurrentHashMap и CopyOnWriteArrayList. Это самый лучший вариант
Вы можете преобразовать список в массив и перебирать массив
Вы можете блокировать изменения списка на время перебора с помощью блока synchronized

Обратите внимание, что последние два варианта негативно скажутся на производительности.

34. Что такое UnsupportedOperationException?
Это исключение возникает при вызове метода, который не поддерживается данной коллекцией.
К примеру, если вы создадите список только для чтения с помощью Collections.unmodifiableList(list), а потом у него вызовете метод add() или remove(), вы точно получите это исключение.

35. Какие классы коллекций позволяют доступ к любому элементу?
Классы ArrayList, HashMap, TreeMap, Hashtable позволяют доступ к любому элементу.

36. Что такое BlockingQueue?
Это очередь, которая позволяет обрабатывать ситуации, когда из пустой очереди пытаются получить элемент, или когда пытаются добавить элемент в очередь, а место в ней закончилось.
Методы блокирующей очереди могут быть четырех типов: Первые вызывают исключение, вторые возвращают специальные значения (null или false, в зависимости от операции), третьи блокируют текущий поток до тех пор пока операция не может быть выполнена, и четвертые блокируют поток только на определенный промежуток времени.
Примеры можно посмотреть в этой  статье.

37. Что такое очередь и стэк, перечислите разницу между ними?
Коллекции, созданные для того чтобы хранить элементы для дальнейшей обработки. Кроме базовых операций интерфейса Collection, очереди поддерживают дополнительные операции добавления, удаления и проверки состояния элемента.
Обычно, но не обязательно очереди работают по принципу FIFO - первым пришел, первым ушел.
Стэк - почти как очередь, но работает по принципу LIFO - последним пришел, первым ушел.
Независимо от порядка добавления/удаления, голова очереди это элемент, который будет удален при вызове методов remove() или poll(). Также обратите внимание на то, что Stack и Vector оба потокобезопасны.

Использование: Используйте очередь если вы хотите обрабатывать поток элементов в том же порядке в котором они поступают. Хорошо для списка заданий и обработки запросов.
Используйте стэк если вы хотите класть и удалять элементы только с вершины стэка, что полезно в рекурсивных алгоритмах.

(А теперь отвлечемся и объясним все чуть иначе.
Итак, представьте обойму автомата. Вы вставляете туда патроны по одному, только с одного конца. И с этого же конца, по одному их будет забирать затворный механизм при стрельбе. Это - стэк, положить элемент можно только на его вершину, снять оттуда же и больше ниоткуда. Последний положенный элемент будет снят первым.
Очередь - как трубка, в которую вы можете закатывать шарики, и с другого конца их забирать. Очередь позволяет класть элементы только в свой хвост, а забирать только с головы. Тот элемент который был первым положен, первым же будет и забран. 
Общее у очереди и стэка только то, что у них обоих есть фиксированное место куда можно положить элемент, и фиксированное место откуда его можно забрать - все остальные элементы недоступны.(Прим. пер.))

38.  Что такое интерфейсы Comparable и Comparator?
В Java, все коллекции поддерживающие автоматическую сортировку, используют методы сравнения для того чтобы правильно рассортировать элементы. В качестве примера таких классов мы можем указать TreeSet, TreeMap и т.д.
Для того чтобы рассортировать элементы, класс должен реализовать интерфейсы Comparator или Comparable. Именно поэтому классы-обертки как Integer, Double и String реализуют интерфейс Comparable. 
Интерфейс Comparable помогает сохранять естественную сортировку, тогда как Comparator позволяет сортировать элементы по разным особым шаблонам. Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает.

(Снова объясняю по другому.
Интерфейс Comparator описывает метод  int compare(T o1, T o2), то есть объект реализующий этот интерфейс может быть использован для сравнения двух других объектов одного класса. Если данный метод вернет 0 - объекты равны, +1 и -1 говорят о том что первый объект "больше" второго или наоборот. Какой смысл вы вложите в понятие "больше" и "меньше" применительно к вашим объектам - исключительно ваше дело. То есть - вы описываете класс, реализующий интерфейс Сomparator, и в данном методе определяете как вы хотите сравнивать ваши объекты. Потом передаете объект этого класса конструктору коллекции, в которой хранятся объекты сравниваемые данным методом, и коллекция сможет их сортировать по возрастанию/убыванию. Повторяю - у вас есть коллекция в которой хранятся объекты класса T, и есть еще один объект, другого класса, реализующего интерфейс Comparator, вся суть которого в том что он умеет сравнивать эти объекты класса T, больше он ни для чего не нужен.
Интерфейс Comparable описывает метод int compareTo(T o), то есть вызывается он не для сравнения двух других объектов, а для сравнения себя самого с кем-то еще. То есть, вам не нужен отдельный объект-сравниватель, вы закладываете механизм сравнения в сам элемент хранящийся в коллекции. Что и в какой ситуации удобнее - решать вам.(Прим. пер.))

39. Что такое классы Collections и Arrays?
Классы Collections и Arrays это специальные служебные классы, для работы с классами-коллекциями. Они позволяют преобразовывать коллекции, делать их защищенными от записи или потокобезопасными, сортировать их разными способами и т.д.

40. Список использованной литературы
Ну, это не вопрос для собеседования. Чисто по приколу. (Но для достижения нирваны вы должны читать как можно больше статей, ваши волосы станут шелковистыми и вьющимися и карма очистится.(Прим. пер.))

Надеюсь эти вопросы помогут вам на следующем собеседовании. В дальнейшем, я советую вам почитать что-нибудь дополнительно. Чем больше вы знаете, тем вам лучше!

Хорошей учебы!



Вопросы к собеседованию ч.1
Вопросы к собеседованию ч.2
