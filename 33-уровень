Level 33

1 Что такое JSON?
JSON (JavaScript Object Notation) - простой формат обмена данными, основанный на подмножестве языка программирования JavaScript.

2 В чем отличия Java и JavaScript?
Это 2 разных языка программирования, несмотря на схожесть их названий. Оба они имеют С-подобный синтаксис. Отличия следующие:
Java реализует ООП подход, основанный на классах, JavaScript — на прототипах;
Java имеет статическую типизацию, JavaScript — динамическую типизацию;
Java загружается из скомпилированного байт-кода; JavaScript интерпретируется напрямую из файла.


JavaScript и Java
Общим заблуждением является то, что JavaScript аналогичен или тесно связан с Java, это не так[30]. Оба языка имеют C-подобный синтаксис, являются объектно-ориентированными и как правило широко используются в клиентских веб-приложениях. Из важных различий можно отметить:

Java реализует ООП подход, основанный на классах, JavaScript — на прототипах;
Java имеет статическую типизацию, JavaScript — динамическую типизацию;
Java загружается из скомпилированного байт-кода; JavaScript интерпретируется напрямую из файла (но часто с незаметной JIT-компиляцией).


3 В чем отличия JSON и XML?
JSON - формат обмена данными.
XML - язык разметки (в котором можно задать синтаксис, структуру, типы данных и вообще их модель).
Оба они могут быть использованы для передачи данных. Естественно, для работы с обоими стандартами используются различные фреймворки, отличается синтаксис.


4 Какие фреймворки для работы с JSON вы знаете?
33 Уровень познакомил нас с фрейворком jackson. В дополнение я приведу еще 3, и ссылку на статью, в которой они сравниваются:
    0. Jackson от FasterXML
    1. JSON.simple от Yidong Fang
    2. GSON от Google
    3. JSONP от Oracle
    
    https://tproger.ru/translations/java-json-library-comparison/
    
    Библиотеки для работы с JSON
Для своих тестов мы выбрали четыре библиотеки — JSON.simple, GSON, Jackson, JSONP — исходя из их популярности на Github, именно они чаще всего используются в проектах на Java.

JSON.simple от Yidong Fang. Небольшая и легковесная библиотека для кодирования и декодирования JSON, несмотря на свою простоту, выполняет свою работу на высоком уровне.
GSON от Google. Библиотека, которая умеет конвертировать Java объекты в JSON и наоборот. Не требует специальным образом аннотировать классы, а также в качестве бонуса имеет полную поддержку Java Generics. Отсутствие необходимости добавления аннотаций упрощает реализацию и даже может быть главным требованием, если вы собираетесь сериализовывать объекты, не имея для них исходного кода.
Jackson от FasterXML. Набор инструментов для обработки данных, основанный на потоковом JSON-парсере и генераторе. Предназначенная для Java библиотека умеет работать не только с JSON. Имеет самый популярный JSON-парсер (исходя из статистики использования на GitHub).
JSONP от Oracle. API для работы с JSON, а именно для генерации и разбора потоковых JSON-текстов. Эталонная реализация JSR353 с открытым исходным кодом.

5 Какие фреймворки для работы с XML вы знаете?
Поскольку XML является форматом представления данных, технологии для работы с ним разнообразнее. Я приведу технологии, используемые для сериализации Java объектов в XML:
    0. JAXB (входит в J в JDK)
    1. Xstream

Ссылка с кратким обзором различных фреймворков для работы с xml:
http://www.duct-tape-architect.ru/?p=315#JAVA_XML

JAVA + XML
JDK хорошо поддерживает все что есть в XML мире. По дефолту включаются почти все парсеры – SAX, StaX, DOM. С версии 1.4+ JDK поддерживает динамическую регистрацию XML-парсеров. Такие парсеры вызываются внутри JDK при использовании его XMl API. Раньше нужно было добавлять парсер как доп. библиотеку, теперь с 1.4 по дефолту используется XERCES, который переписывают от версии к версии. Важно: из за смены JDK могут меняться\ломаться и сами парсеры – от этого переносимость приложения между разными JDK не такая легкая, как того бы хотелось java-разработчикам.

Типы парсеров
SAX parser

Event-driven парсинг
код обрабатывает события такие как: найден начальный тег, найден атрибут, найден конечный тег.
Быстрый по производительности, и простой по реализации
Тяжело написать сложную логику
DOM parser

формируется дерево объектов из элементов с атрибутами;
дерево хранится в памяти, его можно крутить и изменять как угодно, удобно работать со сложными структурами
удобно вычислять XPATH функции
в целях оптимизации некоторые узлы могут не разбираться, пока к ним не обратятся
Pull parser

Среднее между DOM и SAX, парсинг управляется кодом, т.е. ему говорят в какую сторону парсить документ и что вытаскивать.
Хорошая производительность.
Код выходит проще, чем для SAX модели.

6 Какие аннотации Jackson вы знаете?
Разберем те, которые использовались в лекциях:
@JsonAutoDetect - ставится перед классом. Сообщает Jackson, что необходимо использовать поля этого класса при записи или чтении. В скобках можно задать параметр (fieldVisibility = JsonAutoDetect.Visibility.ANY ), для настройки видимости полей, которые будут использоваться (по умолчанию используются только public поля).
@JsonIgnore - ставится перед полем. Сообщает Jackson, что данное поле нужно игнорировать при чтении/записи.
@JsonProperty - Ставится перед полем, getter’ом или setter’ом. Позволяет задать другое имя поля при сериализации. 
@JsonWriteNullProperties - Ставится перед классом. Поля объекта, которые равны null не будет игнорироваться.
@JsonPropertyOrder - Ставится перед классом. позволяет определить порядок, в котором поля java объекта будут сериализованы в JSON.
@JsonDeserialize - Ставится перед полем. Позволяет определить класс, в который десериализуется JSON объект. Например из java массивы и списки сериализуются в массивы, и при десериализации можно выбрать, что именно мы хотим получить.

Вот ссылка на сайт с некоторыми аннотациями:
http://tutorials.jenkov.com/java-json/jackson-annotations.html

7 Какие аннотации JAXB вы знаете?
Так же разберу только те, которые использовались в лекции:
@XmlRootElement - Ставится перед классом. Указывает на то, что этот объект может быть, элементом самого верхнего уровня, т.е. все остальные элементы лежат в нем.
@XmlType - Ставится перед классом. Добавляет в XML-схему дополнительную информацию. Можно указать некоторые атрибуты, например порядок элементов имя и тд.
@XmlElement - Ставится перед полем. Позволяет задать имя xml-элемента, значение по умолчанию и т.д.
@XmlAttribute - Ставится перед полем. Поле будет представлено как XML-атрибут.
@XmlElementWrapper - Ставится перед полем, либо геттером. Позволяет создать обрамляющий тэг для группы элементов.
@XmlJavaTypeAdapter - Ставится перед классом. В скобках указывается вспомогательный класс-адаптер, необходимый для маршилизации/демаршализации данного класса.
@XmlEnum - Ставится перед enum. В скобках можно указать тип, в котором будут представлены значения enum. 
@XmlEnumValue - Ставится перед значением enum. Позволяет задать специальное значение для данного значения enum.

Вот ссылка на сайт с некоторыми аннотациями (извиняюсь, что не сумел составить корректный перевод для аннотаций, информация воспринимается для понимания, но совершенно не представляю, как это грамотно сказать на русском):
https://jaxb.java.net/tutorial/index.html

8 В чем отличие сериализации и десериализации в JSON?
Не понял суть вопроса. Сравнивать 2 взаимообратных процесса смысла не вижу. Возможно имелось ввиду сравнение JSON и XML, на эту тему в следующем вопросе приведена ссылка.

9 Что лучше JSON или XML? Почему?
Вот отличная статья, в которой сравнивается JSON и XML:
https://habrahabr.ru/post/31225/

Пожалуй, нельзя говорить, что что-то лучше. При выборе стоит смотреть на саму задачу и то, что будет эффективнее в использовании. Плюс, выбор может зависеть от личных предпочтений разработчика.

Мой выбор


В случае информационно-ориентированных приложений я предпочту использовать JSON, а не XML, в силу его простоты и легкости обработки данных на стороне клиента. XML может быть незаменимым на сервере, но с JSON определенно проще работать на клиенте.

10 Что такое DTO?
DTO (Data Transfer Object) - паттерн проектирования содержащий данные без какой-либо логики для работы с ними. DTO обычно используются для передачи данных между различными приложениями, либо между слоями внутри одного приложения. Их можно рассматривать как хранилище информации, единственная цель которого — передать эту информацию получателю.

Так как данная тема весьма важна (особенно для будущего Web/Enterprise трудоустройства) лучше немного больше копнуть для самообразования. 

Небольшие дополнения к пунктам:

2) JavaScript уже полноценный язык, который:

 — можно транслировать и использовать как язык программирования общего назначения (прочитайте, например, все что связано с Node JS). Java и JavaScript — это просто два разных языка программирования, имеющих общие 4 буквы в начале :) У них есть схожие и различные черты.



3) XML — язык разметки (в котором можно задать синтаксис, структуру, типы данных и вообще их модель — это можно подробнее узнать посмотрев инфу про XSD и его менее популярного брата DTD). Некоторые такие модели XML стандартизованы (например MathML для описания мат формул с соблюдением семантики). 

JSON — формат обмена данными, к нему также есть дополнительные средства валидации (например JSON Schema — но они пока не используются достаточно широко).



Вопросы по типу 8 и 9 — они скорее всего для того, чтобы понять наличии практики работы с ними будущего кандидата на трудоустройство.

щё не открыл эту лекцию, вот цитата оттуда:

DTO — Data Transfer Object – объект, который создается с целью быть использованным при транспортировке данных. Обычно к таким объектам два требования: а) уметь хранить данные, б) уметь сериализоваться. Т.е. их используют только для пересылки данных.



Создал объект, записал в него нужные данные из бизнес-логики, сериализовал в JSON/XML и отправил куда-надо. Или наоборот – пришло сообщение – десериализовал его в DTO-объект и вытягивай из него данные.
